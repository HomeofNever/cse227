Q1 What problem is this work addressing?
5 Points
Grading comment:
Currently, in order for kernel to run untrusted code from userspace, eBPF is used, specifically in the field of packet filter. However, kernel has to protect itself from its internal state being modified or information leaked. Code validation is used for this purpose. However, it mean that code has to be simple to be successfully validated. There is no support of loop as all branches has to be visited. Memory safety check and performance are also an issue for the old eBPF validation.
Q2 How did the author(s) address the problem?
5 Points
Grading comment:
The paper proposed a memory abstraction which could be efficiently reflect real word eBFP code. Zone abstract domain used for prediction. It also has better asymptotic behavior where linux verifier would timeout. And right now it also support reasoning loop structure. The verifier named PREVAIL, which translates eBPF binaries into a CFG-based language understood by Crab, which then convert the program into three-address instruction set. The analysis is then go through the process of abstraction tags for tracking and a shadow array of tags for each byte in the memory
Q3 Would you have solved the problem differently? If so, how?
5 Points
Grading comment:
It is also stated that most of the them eBFP is not written directly from the bytecode, but C. Although the llvm backend is not part of the trusted code, if we could actually handle these cases on a higher level and the system compiles the target when necessary, which may provide better analysis and also, as the filter itself is not large in nature, should be durable as well.
Q4 What is the most interesting part of the paper?
5 Points
Grading comment:
eBPF is a pretty new model to me and the limited set of instructions introduce in the paper is quite interesting to me.
